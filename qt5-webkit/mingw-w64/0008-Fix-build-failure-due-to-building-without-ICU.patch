From ec65846e33b689741f896b63884b0f9eed0d413d Mon Sep 17 00:00:00 2001
From: Martchus <martchus@gmx.net>
Date: Sun, 25 Sep 2016 22:17:41 +0200
Subject: [PATCH 08/11] Fix build failure due to building without ICU

Revert commit 151422
---
 Source/WebCore/rendering/RenderText.cpp | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/Source/WebCore/rendering/RenderText.cpp b/Source/WebCore/rendering/RenderText.cpp
index cc7607f..eef4363 100644
--- a/Source/WebCore/rendering/RenderText.cpp
+++ b/Source/WebCore/rendering/RenderText.cpp
@@ -100,7 +100,7 @@ static void makeCapitalized(String* string, UChar previous)
         return;
 
     unsigned length = string->length();
-    const StringImpl& stringImpl = *string->impl();
+    const UChar* characters = string->characters();
 
     if (length >= numeric_limits<unsigned>::max())
         CRASH();
@@ -109,29 +109,28 @@ static void makeCapitalized(String* string, UChar previous)
     stringWithPrevious[0] = previous == noBreakSpace ? ' ' : previous;
     for (unsigned i = 1; i < length + 1; i++) {
         // Replace &nbsp with a real space since ICU no longer treats &nbsp as a word separator.
-        if (stringImpl[i - 1] == noBreakSpace)
+        if (characters[i - 1] == noBreakSpace)
             stringWithPrevious[i] = ' ';
         else
-            stringWithPrevious[i] = stringImpl[i - 1];
+            stringWithPrevious[i] = characters[i - 1];
     }
 
     TextBreakIterator* boundary = wordBreakIterator(stringWithPrevious.characters(), length + 1);
     if (!boundary)
         return;
 
-    StringBuilder result;
-    result.reserveCapacity(length);
+    StringBuffer<UChar> data(length);
 
     int32_t endOfWord;
     int32_t startOfWord = textBreakFirst(boundary);
     for (endOfWord = textBreakNext(boundary); endOfWord != TextBreakDone; startOfWord = endOfWord, endOfWord = textBreakNext(boundary)) {
         if (startOfWord) // Ignore first char of previous string
-            result.append(stringImpl[startOfWord - 1] == noBreakSpace ? noBreakSpace : toTitleCase(stringWithPrevious[startOfWord]));
+            data[startOfWord - 1] = characters[startOfWord - 1] == noBreakSpace ? noBreakSpace : toTitleCase(stringWithPrevious[startOfWord]);
         for (int i = startOfWord + 1; i < endOfWord; i++)
-            result.append(stringImpl[i - 1]);
+            data[i - 1] = characters[i - 1];
     }
 
-    *string = result.toString();
+    *string = String::adopt(data);
 }
 
 RenderText::RenderText(Node* node, PassRefPtr<StringImpl> str)
-- 
2.10.2

